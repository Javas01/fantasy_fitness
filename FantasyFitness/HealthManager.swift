//
//  HealthManager.swift
//  FantasyFitness
//
//  Created by Jawwaad Sabree on 6/17/25.
//

import HealthKit

let allTypes: Set = [
    HKQuantityType.workoutType(),
    HKQuantityType(.activeEnergyBurned),
    HKQuantityType(.runningSpeed),
    HKQuantityType(.distanceWalkingRunning),
    HKQuantityType(.vo2Max),
    HKQuantityType(.heartRate)
]

func formatDuration(_ seconds: TimeInterval) -> String {
    let minutes = Int(seconds) / 60
    let secs = Int(seconds) % 60
    return "\(minutes) min \(secs) sec"
}

func convertToImperial(fromMeters meters: Double) -> (miles: Double, feet: Double, yards: Double) {
    let miles = meters / 1609.34
    let feet = meters * 3.28084
    let yards = meters * 1.09361
    return (miles, feet, yards)
}

struct HealthSample: Codable, Identifiable {
    var id: String { sampleId }          // UUID (primary key) generated by supabase
    let sampleId: String
    let userId: String          // UUID (foreign key to users table)
    let quantityType: String    // e.g., "distanceWalkingRunning"
    let distanceMeters: Double
    let startTime: Date         // ISO 8601 format by default with Codable
    let endTime: Date
    let durationSeconds: Double         // seconds
    
    enum CodingKeys: String, CodingKey {
        case sampleId = "sample_id"
        case userId = "user_id"
        case quantityType = "quantity_type"
        case distanceMeters = "distance_meters"
        case startTime = "start_time"
        case endTime = "end_time"
        case durationSeconds = "duration_seconds"
    }
}

extension HealthSample {
    func copy(withDistance distance: Double) -> HealthSample {
        let now = Date()
        let duration = 600.0 // for example, 10 minutes
        let start = Calendar.current.date(byAdding: .second, value: -Int(duration), to: now)!
        let end = now
        
        return HealthSample(
//            id: UUID().uuidString,
            sampleId: UUID().uuidString,
            userId: UUID().uuidString,
            quantityType: self.quantityType,
            distanceMeters: distance,
            startTime: start,
            endTime: end,
            durationSeconds: duration
        )
    }
}

class HealthManager: ObservableObject {
    let appUser: FFUser
    @Published var recentSamples: [HealthSample] = []
    
    init(appUser: FFUser) {
        self.appUser = appUser
    }

    let healthStore = HKHealthStore()
    
    func requestAuthorizationIfNeeded(completion: @escaping (Bool) -> Void) {
        // 1. Check if HealthKit is available
        guard HKHealthStore.isHealthDataAvailable() else {
            completion(false)
            return
        }
        
        // 2. Define data types you want access to
        guard let distanceType = HKObjectType.quantityType(forIdentifier: .distanceWalkingRunning) else {
            completion(false)
            return
        }
        
        let readTypes: Set = [distanceType]
        
        // 3. Check current authorization status
        let status = healthStore.authorizationStatus(for: distanceType)
        
        if status == .notDetermined {
            healthStore.requestAuthorization(toShare: [], read: readTypes) { success, error in
                DispatchQueue.main.async {
                    completion(success)
                }
            }
        } else {
            completion(true) // already authorized or denied
        }
    }
    
    
    private func fetchMostRecentSample(for quantityType: HKQuantityType) {
        let sort = NSSortDescriptor(key: HKSampleSortIdentifierEndDate, ascending: false)
        let predicate = HKQuery.predicateForSamples(withStart: self.appUser.lastSync, end: Date(), options: .strictEndDate)
        
        let query = HKSampleQuery(sampleType: quantityType, predicate: predicate, limit: HKObjectQueryNoLimit, sortDescriptors: [sort]) { query, results, error in
            guard let results = results as? [HKQuantitySample], error == nil else {
                print("Error fetching \(quantityType.identifier): \(error?.localizedDescription ?? "Unknown error")")
                return
            }
            
            DispatchQueue.main.async {
               results.forEach { sample in
                    let id = sample.uuid.uuidString
                    let distanceMeters = sample.quantity.doubleValue(for: .meter())
                    let imperialDistance = convertToImperial(fromMeters: distanceMeters)
                    let start = sample.startDate
                    let end = sample.endDate
                    let duration = end.timeIntervalSince(start) // in seconds
                    print("""
                        ðŸ”¹ Sample ID: \(id)
                        ðŸ”¹ Quantity Type: \(quantityType.identifier,)
                        ðŸ“ Distance: \(String(format: "ðŸ“ %.2f meters = %.2f miles, %.0f feet, or %.0f yards",
                        distanceMeters, imperialDistance.miles, imperialDistance.feet, imperialDistance.yards))
                        â±ï¸ Duration: \(Int(duration)) seconds (\(formatDuration(duration)))
                        ðŸ•’ Start: \(sample.startDate)
                        ðŸ•“ End: \(sample.endDate)
                    """)
                    
                    // Upload to Supabase
                    Task {
                        let newSample = HealthSample(
                            sampleId: id,
                            userId: self.appUser.id.uuidString,
                            quantityType: quantityType.identifier,
                            distanceMeters: distanceMeters,
                            startTime: start,
                            endTime: end,
                            durationSeconds: duration
                        )

                        do {
                            let _ = try await supabase
                                .from("health_data")
                                .insert(newSample)
                                .execute()
                            
                            print("âœ… Inserted new Health Data row")
                            self.recentSamples.append(newSample)
                            let earnedFF = calculateFFScore(distanceMeters: newSample.distanceMeters, durationSeconds: newSample.durationSeconds)
                            // Update user with new FF score
                            let updatedScore = self.appUser.ffScore + earnedFF
                            let _ = try await supabase
                                .from("users")
                                .update(["ff_score": updatedScore])
                                .eq("id", value: self.appUser.id)
                                .execute()
                            
                            print("âœ… Updated FF score to \(updatedScore)")
                        } catch {
                            print("âŒ Failed to insert: \(error)")
                        }
                    }
                }
            }
        }
        
        healthStore.execute(query)
    }
    
    private func unit(for type: HKQuantityType) -> HKUnit {
        switch type.identifier {
            case HKQuantityTypeIdentifier.distanceWalkingRunning.rawValue:
                return .meter()
            case HKQuantityTypeIdentifier.stepCount.rawValue:
                return .count()
            case HKQuantityTypeIdentifier.heartRate.rawValue:
                return HKUnit.count().unitDivided(by: .minute())
            case HKQuantityTypeIdentifier.runningSpeed.rawValue:
                return HKUnit.meter().unitDivided(by: .second())
            default:
                return .count()
        }
    }
    
    func fetchRecentRunningData() {
        self.requestAuthorizationIfNeeded{ success in
            print("Authorization success: \(success)")
            if success {
                let identifiers: [HKQuantityTypeIdentifier] = [
                    .distanceWalkingRunning,
                    .stepCount,
                    .heartRate,
                    .runningSpeed
                ]
                
                for id in identifiers {
                    if let type = HKObjectType.quantityType(forIdentifier: id) {
                        self.fetchMostRecentSample(for: type)
                    }
                }
                Task.detached {
                    do {
                        // Update user's last_sync
                        let _ = try await supabase
                            .from("users")
                            .update(["last_sync": Date()])
                            .eq("id", value: self.appUser.id)
                            .execute()
                        
                        print("âœ… updated user last sync")
                    } catch {
                        print("âŒ Failed to update user last sync: \(error)")
                    }
                }
            }
        }
    }
}

/// Calculates the FantasyFitness score based on distance and speed.
/// - Parameters:
///   - distanceMeters: Distance covered in meters.
///   - durationSeconds: Duration of the activity in seconds.
/// - Returns: FF score as an `Int`.
func calculateFFScore(distanceMeters: Double, durationSeconds: Double) -> Int {
    guard distanceMeters > 0, durationSeconds > 0 else { return 0 }
    
    let baseScore = distanceMeters / 100  // 1 FF per 100 meters
    
    let speedMetersPerSecond = distanceMeters / durationSeconds
    let speedMultiplier: Double
    
    switch speedMetersPerSecond {
        case ..<1.5: speedMultiplier = 1.0      // Slow pace
        case 1.5..<2.5: speedMultiplier = 1.25  // Light jog
        case 2.5..<3.5: speedMultiplier = 1.5   // Steady run
        case 3.5..<4.5: speedMultiplier = 2.0   // Fast run
        default: speedMultiplier = 2.5         // Sprint or elite pace
    }
    
    let score = baseScore * speedMultiplier
    return Int(score.rounded())
}
